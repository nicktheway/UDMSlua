%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a2b173b14a0c1b54abb5999c0fe2102b, type: 3}
  m_Name: ManualSettings
  m_EditorClassIdentifier: 
  skin: {fileID: 11400000, guid: 00eae7324934567439f81c46fd190ad4, type: 2}
  allowEditMode: 0
  stringArray:
  - "   Greetings! This is K-Pathfinder. A tool to generate navigation mesh in a
    grid pattern and some additional data. And possibly navigate your stuff through
    it. It was designed with goal in mind to use it in procedural shooter-like world.
    It's provided \"as is\" and i take no responsibility if it break something or
    if you lose something.  \r\n\r\n\r\nFeatures:\r\n \u2022 Open source (though
    it's hard to read and lacking comments)\r\n \u2022 NavMesh for multiple Agent
    settings at same time\n \u2022 Generate navmesh in runtime\r\n \u2022 Partial
    Update of NavMesh\n \u2022 Areas with different move cost. \n \u2022 Areas can
    be readed from Unity terrain splat map\r\n \u2022 Different passability for Agents.
    Current is \"walking\" and \"crouching\" \r\n \u2022 Covers. Low and high\r\n
    \u2022 Predefined quick samples. For providing bunch of world space points wich
    can be reachable from target position\r\n \u2022 Jump spots to move up and down
    (object to change)\n\u2022 Navmesh Raycasting\r\n \u2022 Search using Layers\n
    \u2022 Local Cost Modifiers"
  - 
  - 
  - This is basic information about agent. It contain only essential information
    for navmesh generation.
  - This is most important information how navmesh should be generated
  - This is information about movement
  - This is information how covers should be generated
  - This is information about samples
  - 'Agent Properties is scriptable object. It define agent archetype. With amost
    every action with PathFinder you need this object. When navmesh generated it
    serves as instruction how to generate navmesh. Or when navmesh already generated
    it serves as key to tell which navmesh should be used.


    Button to create
    agent properties are located in "Window / K-PathFinder / Create Agent Properties".'
  - You can edit it by using Unity Inspector, all options have some tooltips.
  - "<b>Radius:</b> Aproximated agent radisus. I advice to set it slightly larger
    than actual agent.\n\n<b>Height:</b> Agent height in Unity units. Anything below
    this number will be considered as \"Not Walkable\" in navmesh generation. Although
    Agent can have second height for \"crouching\". More on that in Movement tab\n\n<b>Max
    slope:</b> Maximum slope in degrees agent can handle. \n\n<b>Step height:</b>
    Maximum step agent can handle.\n\n<b>Included Layers:</b> Physical Unity layers
    that included into navmesh generation. By default it only contains \"Default\"
    layer. So if anything was excluded from generation that in other layers and you
    expect opposite then add layer to included layers mask.\n\n<b>Ignored Tags:</b>
    Tags that excluded from generation. You can add something by tag to that list
    and it will be ignored in navmesh generation. If \"Use Hierarchy Tag\" enabled
    then PathFinder will check all upper hierarchy of added objects. So for example
    if you add gameobject with \"Armor\" to player then it still will be ignored
    cause it's parent have \"Player\" tag."
  - <b>Voxel Bleed Distance:</b> How far voxels should consider ajaisent information.
    For example there is 2 objects. One is normal and one is "Not Walkable". In left
    example agent have bigger bleed distance. So even if not passable voxels was
    over passable it still take their information because height difference inside
    this threshhold.
  - 'This is done to solve cases when you have small patches of obstacles that going
    through normal navmesh. They are too small to be considered as real obstacle
    but agent will move around them anyway. On the opposite side you might want to
    mark some areas as "Not Walkable" with GameObjects and this feature will be in
    your way.

    It also works with some extent while dealing with different Areas.
    Although it rarely have big effect in that case.


    <b>Voxel Per Chunk Side:</b>
    NavMesh are build from voxels. And PathFinder build navmesh in chunks. This number
    tells how much voxels should be per chunk side. This value specify resolution
    of initial data for NavMesh generation.

    <b>Voxel Size:</b> Size if single
    voxel in Unity units.

    <b>Voxel Per Radius:</b> How much voxels can fit in
    agent Radius. For best results agent radius should be dividable by voxel size.
    I advice to have 2-4 voxels per agent radius. Too big number not really nesessary
    and too small will lead to incorrect results.'
  - '<b>Do NavMesh:</b> Obvoisly enables navmesh generation. This is a thing because
    PathFinder can generate more than NavMesh. And potentialy you might not want
    navmesh itself.


    <b>Walk Cost Modifier:</b> With this number equal to 1
    on navmesh with moving cost 1 final cost will be equal to distance. This value
    to balance moving cost between different agents. For example you want compare
    results for path cost in 2 different agents but one can be genualy slower by
    this number.


    <b>Can Crouch:</b> Agent can have additional navmesh parts
    that generated for smaller height. '
  - 'In this case Path over this NavMesh will have different flag

    <b>Crouch
    Height:</b> Crouch area will be generated between this number and agent actual
    height.

    <b>Crouch Cost Modifyer:</b> Cost modifyer for crouching. If number
    is higher than walk cost then agent will avoid crouhing over this area. There
    is option to search path ignoring crouch cost so i dont advice to just make it
    equal to walk cost.


    <b>Can Jump:</b> PathFinder can generate rough jump
    connections over obstacles'
  - 'Jump Up is yellow, Jump Down is blue.

    <b>Max Jump Up/Down Distance:</b>
    How far agent allowed to jump in different directions. Presumable distance for
    jumping down should be bigger.

    <b>Jump Up/Down Cost:</b> Cost of jumping.
    So agent will avoid unnesesary jumps.'
  - <b>Can Cover:</b>PathFinder have automatic cover generation. If it enabled then
    PathFinder will generate cover. Cover generation is far from perfect but still
    can be userful to aproximate nearby geometry
  - '<b>Cover Full:</b>Height that should cover agent fully

    <b>Can Half-Cover:</b>If
    this option enabled then additional data will be generated for smaller covers

    <b>Cover
    Half:</b>Height that should cover agent when it crouch behind it

    <b>Cover
    Extra Samples:</b>How much extra voxels per agent radius pathfinder should consider
    in cover generation. With 0 covers might have "gaps" and too big number will
    generate covers far off on their borders'
  - If sample points enabled for generation then while navmesh generated some voxel
    samples will be taken as userful data. Samples contain information like passability
    and Area in that point. They are userful to qiuckly test nearby accessable space.
  - Agent is way to get you started with PathFinder. Using Agent is not mandatory
    and it is not optimal solution for every situation but it is default way of doing
    stuff in PathFinder.
  - "Queries is main way to extract userful information from NavMesh in PathFinder.
    \nAll queries derived from <b>NavMeshQueryAbstract<ResultType></b> which have:\n\n<color=blue><i>ResultType
    threadSafeResult</i>\r</color> public value for result that can be accessed in
    Unity main thread\n\n<color=blue><i>SetOnFinishedDelegate(Action<ResultType>
    onFinishDelegate, AgentDelegateMode mode = AgentDelegateMode.NotThreadSafe)</i>\r</color>
    function to add callbacks when query done work. callbacks can be 2 types: \n\u2022
    <b>AgentDelegateMode.ThreadSafe</b> called when result returned to main thread\n\u2022
    <b>AgentDelegateMode.NotThreadSafe</b> called as soon as query finish it execution\n\n<color=blue><i>RemoveOnFinishedDelegate(AgentDelegateMode
    mode = AgentDelegateMode.NotThreadSafe)</i>\r</color> to remove callback\n<color=blue><i>SetMaxExecutionTimeInMilliseconds(int
    maxExecutionTimeInMilliseconds = 5)</i>\r</color> to set max execution time for
    query\n"
  - "Main query for extracting path in PathFinder at this moment. To perform search
    for path you should do:\n\n<b>1) Create Query</b>\nUse the constructor. It reqire
    2 arguments:\n\u2022 AgentProperties to specify what navmesh it should be used\n\u2022
    IPathOwner this value gived to Path when it finished. When path dont have any
    points left it return <color=blue><i>Vector3 pathFallbackPosition { get; }</i>\r</color>
    fallback position that interface provide"
  - "\rAt this moment it perform 5 things:\n \u2022 Wrapper for <b>NavMeshPathQueryGeneric</b>
    which is current way of searching path over navmesh from point A to point B\n\u2022
    Wrapper for <b>Path</b> which is result for path query\n \u2022 Wrapper for <b>NavMeshPointQuery<NodeCoverPoint></b>
    query for searching covers in proximity\n\u2022 Wrapper for <b>NavMeshPointQuery<CellSamplePoint></b>
    query for searching navmesh samples\n \u2022 Wrapper for <b>LocalAvoidanceAgent</b>
    agent that avoid other agents and navmesh\nIt will also initialize all this things
    to simplify some code\n\nThis things expect to have:\n<b>Agent Properties</b>
    Agent always expect to have it. This is information about which navmesh should
    be used\n<b>Layer Mask</b> to describe which navmesh layers should be used\n<b>Modifier
    Mask</b> to describe which cost modifiers should be used to modify cost for queries"
  - "Agent have whole bunch of functions to help navigate simple agents over navmesh:\n\n<color=blue><i>AgentProperties
    properties {get; set;}</i>\r</color> accessor to agent properties. You can init
    agent and it's queries just by setting AgentProperties to this acessor. If you
    creating Agent from code then set it properties first\n<color=blue><i>virtual
    Vector3 positionVector3 {get;}</i>\r</color> accessor to get agent position.
    This accessor used when requesting data from default queries. You can overload
    this accessor to set different input to default queries\n<color=blue><i>virtual
    Vector2 positionVector2 {get;}</i>\r</color> accessor to get 2d agent position.
    It returns (x, z) position of agents. Not (x, y)\n<color=blue><i>List<PointQueryResult<NodeCoverPoint>>
    covers {get;}</i>\r</color> result of default cover query\n<color=blue><i>List<PointQueryResult<CellSamplePoint>>
    sampledPoints {get;}</i>\r</color> result of default sample query\n\n<b><size=20>Requesting
    Information</size></b>\n\n<b>SetGoalMoveHere</b> This is function to request
    Path from PathFinder. It have big list of arguments:\n\u2022 <color=blue><i>Vector3
    start</i>\r</color>: Start position for searching Path. This is optional argiment
    nd there is version that takes current Agent position\n\u2022 <color=blue><i>Vector3
    destination</i>\r</color>: Target position for searching path\n\u2022 <color=blue><i>int
    layerMask</i>\r</color>: You can specify mask for searching on navmesh. this
    is optional argument. if you dont intrested in layered search you can set it
    to 1 in this case only default layer will be included\n\u2022 <color=blue><i>int
    costModifierMask</i>\r</color>: You can specify mask for cost modifiers. this
    is optional argument. this is way to offset navmesh cost by external values \n\u2022
    <color=blue><i>BestFitOptions bestFitSearch</i>\r</color>: Control what query
    should do if it did not find suitable path\n\u2022 <color=blue><i>bool applyRaycast</i>\r</color>:
    Result can potentialy have unnecessary waypoints. If this option enabled then
    path query will attempt to simplify result by using navmesh raycasting. It cost
    some perfomance but noticeable improves result\n\u2022 <color=blue><i>bool collectPathContent</i>\r</color>:
    If enabled then path query will collect external information from navmesh when
    generation path over it\n\u2022 <color=blue><i>bool ignoreCrouchCost</i>\r</color>:
    If enabled then it will ignore cost for crouching. Use this when your agent switch
    it state to constant crouching\n\n<b>SetGoalGetSamplePoints</b> This is function
    to request samples from PathFinder. It have big list of arguments:\n\u2022 <color=blue><i>float
    maxCost</i>\r</color>: Max navmesh distance query should search for data. Huge
    numbers will impact perfomance.\n\u2022 <color=blue><i>int layerMask</i>\r</color>:
    You can specify mask for searching on navmesh. this is optional argument. if
    you dont intrested in layered search you can set it to 1 in this case only default
    layer will be included\n\u2022 <color=blue><i>int costModifierMask</i>\r</color>:
    You can specify mask for cost modifiers. this is optional argument. this is way
    to offset navmesh cost by external values \n\u2022 <color=blue><i>bool richCost</i>\r</color>:
    result have aproximated navmesh cost. If it is true then cost for result will
    be calculated in more precise way. I recomend to enable it if you expect large
    amount of results over small area. And disable if you dont need precission while
    searching over big area\n\u2022 <color=blue><i>bool ignoreCrouchCost</i>\r</color>:
    If enabled then it will ignore cost for crouching. Use this when your agent switch
    it state to constant crouching\n\u2022 <color=blue><i>params Vector3[] positions</i>\r</color>:
    Optional arguments to search from multiple positions at same time. If you use
    overload with that argument agent own position wount be included there\n \n<b>SetGoalFindCover</b>
    This is function to request covers information from PathFinder. It very simmilar
    to sample points and overall same thing. It have big list of arguments:\n\u2022
    <color=blue><i>float maxCost</i></color>: Max navmesh distance query should search
    for data. Huge numbers will impact perfomance.\n\u2022 <color=blue><i>int layerMask</i></color>:
    You can specify mask for searching on navmesh. this is optional argument. if
    you dont intrested in layered search you can set it to 1 in this case only default
    layer will be included\n\u2022 <color=blue><i>int costModifierMask</i></color>:
    You can specify mask for cost modifiers. this is optional argument. this is way
    to offset navmesh cost by external values \n\u2022 <color=blue><i>bool richCost</i></color>:
    result have aproximated navmesh cost. If it is true then cost for result will
    be calculated in more precise way. I recomend to enable it if you expect large
    amount of results over small area. And disable if you dont need precission while
    searching over big area\n\u2022 <color=blue><i>bool ignoreCrouchCost</i></color>:
    If enabled then it will ignore cost for crouching. Use this when your agent switch
    it state to constant crouching\n\n<b><size=20>Path</size></b>\n<color=blue><i>Path
    path {get;}</i></color> accessor to Path from path query\n<color=blue><i>bool
    haveNextNode {get;}</i></color> return if there left nodes in path. return false
    if path null or count > 0. Handy to check if there any waypoints remain in path\n<color=blue><i>PathNode
    nextNode {get;}</i></color> return next node that left in path. If there is no
    nodes left in path it returns agent position with Invalid state\n<color=blue><i>Vector3
    nextNodeDirectionVector3 {get;}</i></color> return (next node position - agent
    position)\n<color=blue><i>Vector2 nextNodeDirectionVector2 {get;}</i></color>
    return (next node position - agent position) on (x, z) axis\n<color=blue><i>virtual
    Vector3 pathFallbackPosition {get;}</i></color> implementation of IPathOwner.
    This position will be returned if path fail to return next node. in default implementation
    it returns transform.position\n<color=blue><i>bool MovableDistanceLesserThan(float
    targetDistance, out float distance, out PathNode node, out bool reachLastPoint)</i></color>
    Check distance of next nodes and returns if movable distance less than target
    distance. This is easy way to check if there Jump node along the way. It have
    multiple overloads with different outputs\n\n<color=blue><i>bool RemoveNextNode(bool
    retainLastNode = false)</i></color> function to shift index of next node in Path.
    Use it when next node are close enough. return true when node was removed. if
    <color=blue>retainLastNode</color> then it never remove last node. Have multiple
    variations:\n<color=blue><i>bool RemoveNextNodeIfCloserSqr(float sqrDistance,
    bool retainLastNode = false)</i></color> Check squared distance to next node
    from agent position and removes it if it closer than target value\n<color=blue><i>bool
    RemoveNextNodeIfCloser(float distance, bool retainLastNode = false)</i></color>
    Do same thing but sqr value for you\n<color=blue><i>bool RemoveNextNodeIfCloserSqrVector2(float
    sqrDistance, bool retainLastNode = false)</i></color> Check squared distance
    to next node from agent position and removes it if it closer than target value.
    Uses (x, z) axis\n<color=blue><i>bool RemoveNextNodeIfCloserVector2(float distance,
    bool retainLastNode = false)</i></color> Do same thing but sqr value for you\n<color=blue><i>bool
    RemoveNextNodeIfCloserThanRadius(bool retainLastNode = false)</i></color> Checks
    if next node closer than agent radius and removes it if it is. Quick and dirty
    way to make agent remove next node\n<color=blue><i>bool RemoveNextNodeIfCloserThanRadiusVector2(bool
    retainLastNode = false)</i></color> Do same thing but uses (x, z) axis\n\n<b><size=20>Callbacks</size></b>\nAll
    this functions have as input AgentDelegateMode. Read about it in Queries/Overview\n<color=blue><i>SetRecievePathDelegate(Action<Path>
    pathDelegate)</i></color> Sets delegate for path query\n<color=blue><i>RemoveRecievePathDelegate()</i></color>
    removes delegate in path query\n\n<color=blue><i>SetRecieveSampleDelegate(Action<List<PointQueryResult<CellSamplePoint>>>
    gridDelegate)</i></color> Sets delegate for samples query\n<color=blue><i>RemoveRecieveSampleDelegate()</i></color>
    removes delegate in path query\n\n<color=blue><i>SetRecieveCoverDelegate(Action<List<PointQueryResult<NodeCoverPoint>>>
    coverDelegate)</i></color> Sets delegate for cover query\n<color=blue><i>RemoveRecieveCoverDelegate()</i></color>
    removes delegate in cover query"
  - Main Menu is main control panel for PathFinder. You can find it in Window/K-PathFinder/Menu
  - In this menu toy can build and save navmesh, change settings for generation and
    debug navmesh
  - This tab is main controls for building and saving navmesh. All buttons here can
    be called from code.
  - '<b>Properties</b> Current target properties this menu interacting with. '
  - <b><size=20>Build Area Sellector</size></b>
  - "In PathFinder navmesh generates in chunks. You can call from code \"make navmesh
    from here to there\" but you also can sellect target chunks for navmesh generation
    using this sellector. \nYou can ajust size of sellector by pulling pins on it
    sides. It only sellect chunks to no \"half chunks\". Or you can move it around
    using central quad. Up and downarrow purely aesthetic and don't participate in
    anything besides moving sellector up and down.\nSellector values are measured
    in \"Chunks\".\n\n<b>Start</b> Chunk position where sellector start.\n\n<b>Size</b>
    How much chunks sellected in given positive direction.\n\n<b>Move</b> Snaps sellector
    to cursor if it far off screen.\n\n<b>Reset</b> Reset sellector to [Start X:0,
    Z:0][Size X:1, Z:1]"
  - "<b><size=20>NavMesh Building</size></b>\n\n<b>Build</b>: Build button are obvious.
    It will build NavMesh in sellected area when you press it.\nTo use this button
    from code use there is bunch of ways:\r\n\nWill queue NavMesh in sellected area:\r\n\u2022
    <color=blue><i>PathFinder.QueueGraph(Vector2 worldTopPosition, AgentProperties
    properties)</i>\r</color>\n\u2022 <color=blue><i>PathFinder.QueueGraph(Vector3
    worldPosition, AgentProperties properties)</i>\r</color>\n\u2022 <color=blue><i>PathFinder.QueueGraph(int
    x, int z, AgentProperties properties, int sizeX = 1, int sizeZ = 1)</i>\r</color>\n\u2022
    <color=blue><i>PathFinder.QueueGraph(XZPosInt pos, AgentProperties properties)</i>\r</color>\n\u2022
    <color=blue><i>PathFinder.QueueGraph(XZPosInt pos, XZPosInt size, AgentProperties
    properties)</i>\r</color>\n\u2022 <color=blue><i>PathFinder.QueueGraph(Vector2
    startTop, Vector2 endTop, AgentProperties properties)</i>\r</color>\n\u2022 <color=blue><i>PathFinder.QueueGraph(Vector3
    start, Vector3 end, AgentProperties properties)</i>\r</color>\n\u2022 <color=blue><i>PathFinder.QueueGraph(Bounds
    bounds, AgentProperties properties)</i></color> Put here target bounds in world
    space and it will queue all chunks it overlap\n\n<b>Remove</b>: Removes NavMesh
    targeted by area selector. If checkbox next to it are enabled then after removing
    PathFinder will queue removed chunks again and redo them.\r\nTo use this button
    from code use:\n\u2022 <color=blue><i>PathFinder.RemoveGraph(GeneralXZData data,
    bool createNewGraphAfter = true)</i></color>\n\u2022 <color=blue><i>PathFinder.RemoveGraph(XZPosInt
    pos, AgentProperties properties, bool createNewGraphAfter = true)</i></color>\n\u2022
    <color=blue><i>PathFinder.RemoveGraph(int x, int z, AgentProperties properties,
    int sizeX = 1, int sizeZ = 1, bool createNewGraphAfter = true)</i></color>\n\u2022
    <color=blue><i>PathFinder.RemoveGraph(Bounds bounds, AgentProperties properties,
    bool createNewGraphAfter = true)</i></color>\n\u2022 <color=blue><i>PathFinder.RemoveGraph(AgentProperties
    properties, bool createNewGraphAfter = true, params Bounds[] bounds)</i></color>\n\nInput
    are in chunk position. There is also a version with Bounds which will convert
    bound position to chunk position and use these values as input. \r\n\r\n<b>Clear</b>:
    Will remove all existed NavMesh and stop all existed work.\nTo use this button
    from code use <color=blue><i>PathFinder.ClearAll()</i></color>"
  - "<b><size=20>NavMesh Saving</size></b>\n\r\n By default serialization implemented
    by storing SerializedNavmesh in SceneNavmeshData:ScriptableObject. When you attempt
    to save current navmesh this scriptable object will be created. \r\n\r\nYour
    Serialization buttons.\r\n<b>Save</b>: If you press this button then if your
    scene dont have SceneNavmeshData associated with it then PathFinder suggest you
    to create one and put all current NavMesh inside it. To use this from code use
    <color=blue><i>PathFinder.SaveCurrentSceneData()</i>\r</color>\n<b>Load</b>:
    Are obviously try to load SceneNavmeshData in current scene you can use it from
    code use <color=blue><i>PathFinder.LoadCurrentSceneData()</i></color> but it
    will done automatically anyway while PathFinder are starting up.\r\n<b>Delete</b>:
    Will delete all data inside current SceneNavmeshData. Also, if you want to delete
    some particular layer of NavMesh then you can select SceneNavmeshData associated
    with current scene and press Remove button near undesired AgentProperties."
  - 
  - "<b>Helper name</b>: In order PathFinder to work it needs to use Unity API. After
    you start using PathFinder it will create object to use Unity API in scene and
    you can specify its name here. Along with runing Unity API this GameObject will
    store SceneNavmeshData. For example if you copying scene then you can just put
    here copy SceneNavmeshData from another scene.\n\r\n<b>Multithread</b>: Enabled
    by default. Putted here entirely for debugging. Cause debugging threads is pain.
    If disabled then all navmesh generating code will be executed in main thread.\n\r\n<b>Max
    threads</b>: Obviously control the maximum amount of active threads. But actially
    you can control it in code using <color=blue><i>PathFinder.SetMaxThreads(int
    value)</i></color>. When scene starting and you want to build NavMesh as quickly
    as possible you can put here big enough number. But when you want your silky
    smooth FPS then you tune down maximum threads and PC wont struggle to create
    all you throw at PathFinder.\r\n\r\nOptions to control method of rasterization:\r\n<b>Terrain
    collection</b>\r\n<b>Collider collection</b>\r\nInitialy navmesh generate lots
    of voxels to generate NavMesh later on. Here you can define prefered method.
    All of them have pros and cons.\r\nBouth have CPU version and ComputeShader version.
    \r\nCPU are slower but dont go outside given thread so it's good when you want
    to have smooth FPS.\r\nComputeShader are very faster and use GPU to get this
    data. But moving data back and forth from GPU are slow. And there is pretty big
    data. When you make small amount of chunks it will be superfast but you will
    have FPS drops if you start generate big.\r\n\r\n<b>World grid size</b>: This
    number will tell how big your NavMesh chunks in world space. Default is 10 but
    it might be a bit small. Good chunk size depends on your world size, around 20-50
    chunks per world side is a good number. Too big chunks will take too long time
    to update and too small will take long time to create in row and will also lead
    to bad pathfinding. So if you want some optimisation this is probably where you
    should start.\n\r\n<b>Chunk max/min height</b>: Just a crutch for Unity. When
    NavMesh are generated it stored inside Chunk. And Chunk are describe where PathFinder
    should to check for colliders. And when Chunk are generated this values will
    tell PathFinder from where it should start boxcasting and where should stop boxcasting
    to get Chunk size. Numbers here are in chunk size. I have no clue how big your
    world are so just enter here right numbers if navmesh not generated at target
    height.\r\n   Actualy, this options doesn't normally exist cause normally NavMesh
    built in one go. If this were applicable to PathFinder then it simply check all
    colliders and watch where bounds for all of them. But i cant do this if there
    bazillion colliders in scene cause it need to be checked for every chunk in every
    NavMesh generation in that chunk."
  - <b><size=20>Area Editor</size></b>
  - "Navigation can have different cost. Somewhere is normal area and Agent will
    navigate there with normal time, somewhere is road and Agent will navigate there
    with half of time and somewhere is swamp and it should avoid this area. In PathFinder
    this spatial divisions called \"Area\". In this menu edited global library of
    Areas.\n\n<b>Color</b> Graphical definition of Area. When navmesh debuged it
    will have this color.\n\n<b>Cost</b> Presumable this is amount of time Agent
    should spend while moving on this Area. \n\n<b>Priority</b> This value control
    how different areas layer on top of each others. You can real about this in \"Properties/Voxel/Voxel
    Bleed Distance\" \n\n0 and 1 are reserved. PathFinder always should have default
    walkable and default unwalkable areas."
  - <b><size=20>Tag Association</size></b>
  - "Here you specify default Area for target Tag. Cause adding AreaGameObject can
    be painful to large number of objects. Userful if you want to quickly make all
    your furniture Not Walkable by default. \r\nIf \"Use Root Tag\" enabled then
    for chosing area will be sellected topmost parrent of gameObject. Userful if
    you organizing your scene using gameObjects as folders. So for example all forks,
    spoons and dishes became unwalkable if whey parented to table."
  - <b><size=20>Layer Editor</size></b>
  - PathFinder have ability to perform "Layered" operations. It work very much like
    Unity Physics. You specify for some part of navmesh it's layer and include or
    exclude it into some operation. Here you control naming fpr layers. Although
    right now you can use layers without naming them and it does not realy change
    anything. But keep in mind that first 8 indexes are reserved.
  - <b><size=20>PathFinder thread log</size></b>
  - Basic way to monitor how PathFinder main thread is doing. If something went really
    wrong some of "Success" will be "Failure" and this will tell where all bad stuff
    happen. Or maybe PathFinder have nothing done yet since this is simply flags
    "is you reach this part of code"
  - <b><size=20>Important checkboxes</size></b>
  - "<b>Do debug</b> If true then while generating some basic debug will be done.
    In this case PathFinder will collect to debuger navmes, connections, covers,
    etc so it can be visible. All things that can in some way be userful for Agent.
    This option controls collection of this information. So if you enable it in checkboxes
    below but dont actualy allow collecting of this information it will not append.
    \n\n<b>Full debug</b> Enables collection of <i>a lot more heavy</i> debug. In
    this case all individual voxels and their connections and all intermediate information
    will be collected and avaiable for debug. This will quickly eat lots of memory.
    Used for troubleshoot navmesh generation step by step.\n\n<b>Do profiler</b>
    If true PathFinder will also collect time that take for chunks to be generated.
    It will append in Console like that:"
  - 'It have timestamps when something happen. Also it contain all important information
    what participate in navmesh generation and reasons why anything was excluded
    from generation.


    <b>Content Map </b> PathFinder have internal way to store
    information with bounding boxes. It this enabled it will show where it stored.
    By default it include "Trees" and "Area Modifiers".'
  - You can locate this component in PathFinder/Components/AreaCameObject.cs
  - This object changes Area of target GameObject regardles other settings. It only
    changes to Area from global Area list.
  - 'You can locate it in <i>PathFinder/Components/AreaWorldMod.cs</i>

    Or you
    can create empty gameObject with this component using <i>Window/K-PathFinder/Create
    Area Moifier</i>


    This is quite multi-purpose object.

    Main purpose
    of this object is Area marker. It marks some space using some gizmos shapes.
    Shapes list are at the bottom.'
  - 'At this moment you can add Cube, Sphere and Capsule.

    Removing or rearranging
    is through context menu buttons. If you click on object in that menu it will
    be highlited in scene.


    At marked with shapes area right now it can perform
    4 things:'
  - '<b>Solid</b> In this case it will be much like normal GameObject. Though there
    is no actual GameObject. Userful in combination with other stuff. Cause for example
    it still generate covers. So you can fix cover generation using it that way for
    example.


    <b>Modify Area</b> Changes in target space voxels to match sellected
    Area. It actualy should overlap where voxels are.


    <b>Make Hole Apply Area</b>
    Makes hole in solid mesh for navigation and change new voxels to sellected Area.
    Userful if for example you have destructible environment. Or if you just want
    to say "Here is hole. I''m sure." It dont actualy make hole. Just convince PathFinder
    that here is hole.


    <b>Make Hole Retain Area</b> Make hole in solid mesh
    but take Area above removed space.


    <b><size=20>Area Options</size></b>

    It
    have 2 modes:

    Use Advanced Area = false'
  - 'In this mode it do everything described above using Areas from global Area List.


    Use
    Advanced Area = true'
  - "Enabling Advanced Area opens up some options. In this case Area Modifier generates
    it's own Area. And this Area collects NavMesh that was used in it generation.
    This make it avaiable to further changes.\n\n<b>Layer</b> In PathFinder you can
    perform layered search. More on that in \"Features and Limitations/Layers\".
    Inside Inspector you can change default Layer for this particular space.\n\nRelated
    functions:\n<color=blue><i>SetCellsState(bool canBeUsed)</i>\r</color> Exist
    to support old API. If true: changes Layer to \"Default\". If false: to \"Ignore\"\n<color=blue><i>SetCellsState(bool
    canBeUsed, params AgentProperties[] targets)</i>\r</color> Do same thing but
    you can sellect AgentProperties it affects\n<color=blue><i>SetCellsLayer(int
    targetLayer)</i>\r</color> Set to target zone target Layer by it's index in Layer
    Editor.\n<color=blue><i>SetCellsLayer(int targetLayer, params AgentProperties[]
    targets)</i>\r</color> Do same thing but you can sellect AgentProperties it affects\n\n<b>Cell
    Path Content</b> This is not listed in Inspector and only avaiable through code.
    PathFinder can register some user defined data inside NavMesh. And this data
    will be avaiable in generated Path. More on that in \"Features and Limitations/Cell
    Path Content\"\n\nFunctions to add:\n<color=blue><i>AddCellPathContent(CellPathContentAbstract
    value)</i>\r</color>\n<color=blue><i>AddCellPathContent(IEnumerable<CellPathContentAbstract>
    values)</i>\r</color>\n<color=blue><i>AddCellPathContent(params CellPathContentAbstract[]
    values)</i>\r</color>\n\nFunctions to remove:\n<color=blue><i>RemoveCellPathContent(CellPathContentAbstract
    value)</i>\r</color>\n<color=blue><i>RemoveCellPathContent(IEnumerable<CellPathContentAbstract>
    values)</i>\r</color>\n<color=blue><i>RemoveCellPathContent(params CellPathContentAbstract[]
    values)</i>\r</color>\n"
  - "It can be used to achive opposite effect - to lure agent to some space. In this
    case cost should be negative. This is userful if for example you need to avoid
    throwed grenade. Or space out some agents. Or joint paths together.\n\n\nYou
    dont actualy need component itself. You can create <b>DeltaCostValue</b> through
    code and use:\n<color=blue><i>PathFinder.AddDeltaCostValue(DeltaCostValue value)</i>\r</color>
    To add this value\n<color=blue><i>PathFinder.RemoveDeltaCostValue(DeltaCostValue
    value)</i>\r</color> To remove this value\nAlthough this feature will probably
    be changed multiple times while PathFinder being developed and using component
    is adviced since it probably wount breaks much between updates"
  - 'Layers used to include or exclude NavMesh parts from some operations. You can
    selectively ignore some parts of NavMesh during navigation or searching.


    <b><size=20>How
    to create Layer</size></b>

    To create new Layer open PathFinder manu and
    navigate to Settings tab.

    You can assign name of layer to any index from
    8 to 31.'
  - "To enable Local Avoidance set checkbox <b>Dynamic Obstacle Agent</b> or use\n<color=blue><i>PathFinderAgent.velocityObstacle</i>\r</color>
    after you set AgentProperties. After that will be avaiable bunch of options:\n\n<b>Max
    Neighbors</b> Maximum number of neighbors that avoided. Will be chosen nearest
    agents possible. \nUse <color=blue><i>PathFinderAgent.maxNeighbors</i>\r</color>
    to edit this value from code.\n\n<b>Max Neighbor Distance</b> Maximum distance
    to any neighbor affect this Agent. If neighbor is further than this number then
    it will not be added to neighbor list.\nUse <color=blue><i>PathFinderAgent.maxNeighbourDistance</i>\r</color>
    to edit this value from code.\n\n<b>Max Velocity</b> Agent maximum velocity that
    available for evasion. For better effect set it to agent max velocity. For example
    if agent can run but it's walk most of the time you should set this value to
    agent runing speed. Cause it directly affect agenet avaiable space for velocity
    change. More space - more possible results.\nUse <color=blue><i>PathFinderAgent.maxAgentVelocity</i>\r</color>
    to edit this value from code.\n\n<b>Avoidance Responsibility</b> Agent have different
    responsibility for evasion. For example one agent can take 90% of responsibility
    and other 10%. This value is normalised for every agent pair. So for example
    if one agent have 0.3 and other 0.1 then it is equal to 75% and 25% of responsibility.
    Responsibility is how much from delta-velocity will be taken to nearest point
    on collision cone\nUse <color=blue><i>PathFinderAgent.avoidanceResponsibility</i>\r</color>
    to edit this value from code.\n\n<b>Care Distance</b> In this local avoidance
    implementation collision cones are \"truncated\" so agent dont avoid other agent
    as soon as it append in it neighbour list. When agents near each other it will
    be more smooth transiction to evade it neighbour. This option define where collision
    cone truncated in normalised disnace to this agent. Don't set this value outside
    0.01-0.99 range or will be bugs. When value is 0.01 agent will be evaded by other
    agents as soon as possible. When value is 0.99 then this agent will be ignored
    by other agents until the end. \nUse <color=blue><i>PathFinderAgent.careDistance</i>\r</color>
    to edit this value from code.\n\n<b>Deadlock Fail-Safe</b> Experimental feature.
    In rare cases 3 or more agents can just start sitting near each other because
    they cant go left or right equaly. If this option enabled then agent will try
    to \"shake\" too static agent.\nUse <color=blue><i>PathFinderAgent.useDeadLockFailsafe</i>\r</color>
    to edit this value from code.\n\n<b>DL Velocity Threshold</b> velocity below
    agent can be considered deadlocked.\nUse <color=blue><i>PathFinderAgent.deadLockVelocityThreshold</i>\r</color>
    to edit this value from code.\n\n<b>DL Fail-Safe Velocity</b> velocity that agent
    will be pushed out from other agents when it trying to shake deadlock\nUse <color=blue><i>PathFinderAgent.deadLockFailsafeVelocity</i>\r</color>
    to edit this value from code.\n\n<b>DL Fail-Safe Time</b> how much time should
    pass before agent will return to normal state\nUse <color=blue><i>PathFinderAgent.deadLockFailsafeTime</i>\r</color>
    to edit this value from code.\n\n<b>Prefer One Side</b> If this option enabled
    then Agent will make collision cone slightly larger on left side. And thus will
    more prone to evade to right side.\nUse <color=blue><i>PathFinderAgent.preferOneSideEvasion</i>\r</color>
    to edit this value from code.\n\n<b>Side Offset</b> how far left side of collision
    cone should be offseted\nUse <color=blue><i>PathFinderAgent.preferOneSideEvasionOffset</i>\r</color>
    to edit this value from code.\n\n\n<b><size=20>How to use it</size></b>\nIn PathFinder
    all Agents updates at same time. To perform Update for local avoidance solver
    use <color=blue><i>PathFinder.UpdateRVO()</i>\r</color> function. It will flip
    some flags and update PathFinder. I suggest to run somewhere in scene Unity \"Update()\"
    function and call \"UpdateRVO()\" inside it.\n\n<b>Before Update</b>: Agent should
    know 3 values:\n \u2022 World Position: Set it by setting <color=blue><i>LocalAvoidanceAgent.position</i>\r</color>
    it's position. This is Vector3 value. In case PathFinderAgent you can skip it
    since it set it's position on it's own. You should set this value if you using
    LocalAvoidanceAgent.\n \u2022 Velocity: Set it by setting <color=blue><i>LocalAvoidanceAgent.velocity</i>\r</color>
    it's velocity. This is Vector2 value and velocity should be on (X,Z) axis in
    top view.\n \u2022 Preferable Velocity: Set it by setting <color=blue><i>LocalAvoidanceAgent.velocity</i>\r</color>
    it's world velocity. This is Vector2 value and velocity should be on (X,Z) axis
    in top view. This is direction Agent actualy wants to move.\n\n<b>After Update</b>:
    Agent will recieve closest to preferable velocity to <color=blue><i>LocalAvoidanceAgent.safeVelocity</i>\r</color>
    where it dont collide with anything in (X,Z) projection. This is only result
    from local avoidance solver."
  - 'In PathFinder you can assign Area automaticaly on terrain with this component.

    You
    can find it in folder <i>PathFinder/Components/TerrainNavmeshSettings.cs</i>'
  - 'If this component present in Terrain then PathFinder will read Terrain texture,
    check what biggest value there and assign Area accordingly.

    You can use
    Area only from global Area List.'
  - "You can assign this values from code using:\n<color=blue><i>SetArea(int splatMapIndex,
    int area)</i>\r</color>\n<color=blue><i>SetArea(int splatMapIndex, Area area)</i>\r</color>\nsplatMapIndex
    is index of SplatPrototype (for Unity < 2018.3) or TerrainLayer (for Unity >
    2018.3) in terrain.terrainData\n\nI recoment to read \"General/Helpful Attributes\"
    cause there is one that draw int as Area to help you setup it in your code"
  - '<b>AreaAttribute</b>

    You can draw Area dropdown menu if you use this attribute
    before int.'
  - '<b>LayerPFAttribute</b>

    You can draw PathFinder Layers if you use this
    attribute before int.'
  - "You can register on NavMesh some User-defined data using this. And later on
    extract it by using Queries or some different way.\n\nBy default it implemented
    with \n<i>PathFinder/Components/NavMeshContent.cs</i>\nThis is MonoBehaviour
    component that you can derive from. It will automaticaly add itself to PathFinder
    and update when moved. But using it is not mandatory. You can derive from interface:"
  - "With help of <b>Area Modifier</b> you can add to navmesh data that can be accessed
    after PathFinder generates Path over where that Path Content stored. This is
    userful to store on actual NavMesh some metadata about world. For example you
    can add to NavMesh state of door along with way to open this door. Or add to
    passage information about fee or whatever.\n\nIt should be derived from:\n<color=blue><i>abstract
    class CellPathContentAbstract</i>\r</color>\nFor example:"
  - 'Also in PathFinder there is simple struct to help work with Bit Masks. It called
    "BitMaskPF". ThisAttribute also can be used with it. '
  - "In PathFinder there is simple Local Avoidance implementation. At this moment
    Agents can evade each others (in some degree) and navmesh borders.\n\nIt have
    it's own agent: <b>LocalAvoidanceAgent</b> \nAfter you create it you should register
    it in PathFinder by using:\n<color=blue><i>PathFinder.RegisterLocalAvoidanceAgent(LocalAvoidanceAgent
    agent)</i>\r</color>\n\nOr you can use <b>PathFinderAgent</b> since it is wrapper
    for LocalAvoidanceAgent and do it for you.\nLater on local avoidance will be
    probably heavily changed to more ECS friendly version so i advice to use PathFinderAgent
    since it will probably retain it's API.\n\nSince only PathFinderAgent have Inspector
    and intended to be used for beginners it will be mainly covered in this Manual.
    But all information here also applicable to LocalAvoidanceAgent."
  - 'In PathFinder there is way to dynamicaly change NavMesh cost in some degree.
    It is not accurate in any mean but userfult when you actualy dont need much accuracy.


    You
    can find it in folder <i>PathFinder/Components/CostModifier.cs</i>


    You
    have up to 32 delta cost groups. (lesser number will eat less memory)

    Chosing
    group done by using bitmask. There is bunch of methods that allow input of this
    bitmask in Queries.  '
  - '<b>Properties</b> AgentProperties it affects


    <b>Group</b> Group of current
    modifier. You can have as much modifiers as you want inside one group. Finite
    delta-cost for navmesh is sum of modifiers inside group.


    <b>Multiplier</b>
    Way to affect final result. Only values from 0f to 1f will affect result. Formula
    is Multiplier.Evaluate([current cost]/ [max cost]) * [max cost]. i.e. you take
    current normalized to max navmesh cost distance, put it into multiplier and multiply
    by max cost.

    Later on it will probably be reduced to just 2 KeyFrames to
    improve perfmance (i had no time to write custon editor for that)


    <b>Max
    Navmesh Cost</b> Maximum distance on navmesh Delta Cost affect from it position


    It
    can be used for example to avoid some space. Agent on that picture tries to find
    suitable cover position. Delta cost affects cover result and agent tries to find
    furthest position on navmesh from target position AND generate path that move
    aroundtarget position cause it simply costs more.'
  - '<b><size=20>How to assign Layer</size></b>

    To assign layer to part of NavMesh
    you should use AreaModifier. You can read about it in Components/AreaModifier
    tab.

    Create one, mark some space using it, sellect Mode: "Modify Area" and
    finaly set to true checkbox "Use Advanced Area".


    After that you can assign
    Layer in bottom of that menu.

    Navmesh can only have single Layer value.'
  - '<b><size=20>How to use Layer</size></b>

    At this moment there is 2 ways
    to use it:


    You can sellect used layers in Layer Mask in PathFinderAgent
    component:'
  - '[box] MyBox'
  - "In this case Agent will use this layer mask inside it's things if you dont specify
    other layer mask.\n\nOr you can specify layer mask in queries or in PathFinderAgent
    when you use it. For example it have function:\n<color=blue><i>SetGoalMoveHere(Vector3
    destination, BestFitOptions bestFitSearch...)</i>\r</color>\nBut it also have
    overload:\n<color=blue><i>SetGoalMoveHere(Vector3 destination, <b>int layerMask,</b>
    int costModifierMask, BestFitOptions bestFitSearch...)</i></color>\n\nit have
    Int32 as input. To simplify creating propper input you can use build in <b>BitMaskPF</b>
    struct and <color=blue><i>PathFinder.StringToLayer(string layer)</i></color>\nFor
    example like that:"
  - "public interface ICellContentValueExternal : ICellContentValue {\n    float
    maxNavmeshDistance { get; }\n}\r"
  - "And use:\n<color=blue><i>PathFinder.ProcessCellContent(ICellContentValueExternal
    value)</i>\r</color> to Add or Update target value\n<color=blue><i>PathFinder.RemoveCellContent(ICellContentValueExternal
    value)</i>\r</color> to Remove target value\n\nAt this moment main way to extract
    registered values from NavMesh is <b>NavMeshPointQuery\r</b>\nThis is userful
    cause you can quickly check what accessable near Agent. For example you can register
    on navmesh some dropped Items and quickly check what Items are near your Agent
    and send agent there. Or you can register Agent itself on navmesh this way and
    check which Agent nearby."
  - '[Area] public int myArea;'
  - 'Will look like that in Inspector:'
  - Will look like that
  - '[Area] public int myArea;'
  - 'Will look like that in Inspector:'
  - '[LayerPF] public BitMaskPF myLayers;'
  - '[LayerPF] public int myLayer;'
  - 'Will look like that in Inspector:'
  - '[LayerPF] public int myLayer;'
  - Will look like that
  - '[LayerPF] public BitMaskPF myLayers;'
  - Will look like that
  - 'BitMaskPF myMask = new BitMaskPF();

    myMask[PathFinder.StringToLayer("Default")]
    = true;

    myMask[PathFinder.StringToLayer("Ignore")] = true;'
  - 'And use "myMask" as input to mentioned function.


    Or you can use [LayerPF]
    Attribute in combination with BitMaskPF. '
  - '[LayerPF] public BitMaskPF myLayers;'
  - 'will look like that:'
  - 'AgentProperties properties;

    IPathOwner pathOwner;

    NavMeshPathQueryGeneric
    myPathQuery = new NavMeshPathQueryGeneric(properties, pathOwner);'
  - "\n<b>2) Queue Path</b>\nAfter you create Query you should use it's function
    <color=blue><i>QueueWork</i>\r</color>\nIf have large amount of arguments and
    optional arguments:\n\u2022 <color=blue><i>Vector3 start</i>\r</color>: Start
    position for searching Path. This is optional argiment nd there is version that
    takes current Agent position\n\u2022 <color=blue><i>Vector3 target</i>\r</color>:
    Target position for searching path\n\u2022 <color=blue><i>int layerMask</i>\r</color>:
    You can specify mask for searching on navmesh. this is optional argument. if
    you dont intrested in layered search you can set it to 1 in this case only default
    layer will be included\n\u2022 <color=blue><i>int costModifierMask</i>\r</color>:
    You can specify mask for cost modifiers. this is optional argument. this is way
    to offset navmesh cost by external values \n\u2022 <color=blue><i>BestFitOptions
    bestFitSearch</i>\r</color>: Control what query should do if it did not find
    suitable path\n\u2022 <color=blue><i>bool applyRaycast</i>\r</color>: Result
    can potentialy have unnecessary waypoints. If this option enabled then path query
    will attempt to simplify result by using navmesh raycasting. It cost some perfomance
    but noticeable improves result\n\u2022 <color=blue><i>bool collectPathContent</i>\r</color>:
    If enabled then path query will collect external information from navmesh when
    generation path over it\n\u2022 <color=blue><i>bool ignoreCrouchCost</i>\r</color>:
    If enabled then it will ignore cost for crouching. Use this when your agent switch
    it state to constant crouching\n\u2022 <color=blue><i>bool updatePathFinder</i>\r</color>:
    If true then after you queue work pathfinder will automaticaly updated. if you
    want to save up some perfomance you can batch some work within some time and
    call PathFinder.Update() youself\n\nAll arguments after \"start\" and \"target\"
    is optional. I recomend to assign arguments by name. For example:"
  - "public class MyCellContent : CellPathContentAbstract{\n    public bool myValue;\n}"
  - "This class have 2 virtual methods: \n<color=blue><i>virtual void OnAddingToCell(Cell
    cell) { }</i>\r</color> called when this value added to cell\n<color=blue><i>virtual
    void OnRemovingFromCell(Cell cell) { }</i>\r</color> called when this value removed
    from cell\n\nThen you can optionaly collect this content when you set to true
    this argument\n<color=blue><i>PathFinderAgent.<color=blue><i>SetGoalMoveHere(Vector3
    destination..., <b>bool collectPathContent</b> ...)</i>\r</color></i>\r</color>\nAlso
    NavMeshPathQueryGeneric have this optional argument\n\nThen when Agent (or query)
    recieve resulted Path it wull contain in <color=blue><i>Path.pathContent</i>\r</color>
    all CellPathContentAbstract it gather along the path."
  - "public class ExampleClass : MonoBehaviour, IPathOwner {\r\n    public AgentProperties
    properties;\r\n    public Vector3 pathTarget;\r\n    private NavMeshPathQueryGeneric
    myPathQuery;\r\n\r\n    void Start() {\r\n        myPathQuery = new NavMeshPathQueryGeneric(properties,
    this);\r\n    }\r\n\r\n    void Update() {\r\n        <b>myPathQuery.QueueWork(transform.position,
    pathTarget, applyRaycast: true, collectPathContent: true);\r</b>\n    }\r\n\r   
    \n    //implements IPathOwner\n    public Vector3 pathFallbackPosition {\r\n      
    get { return transform.position; }\r\n    }\r\n}"
  - "\n<b>3) Receive Path</b>\nAfter you queue Path this query will add itself to
    current queue of queries and optionaly force PathFinder to update. When PathFinder
    update itself in it's own thread Query will perform searching of Path.\nAfter
    it all done you can use <color=blue><i>threadSafeResult</i>\r</color> variable
    inside query"
  - "    void Update() {\r\n        myPathQuery.QueueWork(transform.position, pathTarget,
    applyRaycast: true, collectPathContent: true);\r\n        Debug.Log(\"Path have
    \" + <b>myPathQuery.threadSafeResult.count</b> + \" nodes\");\n    }\r"
  - "I advice you to use this variable when you intercting with Path and don't cache
    it. Cause Path is pooled value and it will return to pool on next QueueWork.\n\nIf
    you want actual copy of Path then use <color=blue><i>Path.Copy()</i>\r</color>\nWhen
    you done with copy dont forget to return it to pool by using <color=blue><i>Path.ReturnToPool()</i>\r</color>"
  - "    void Update() {\r\n        myPathQuery.QueueWork(transform.position, pathTarget,
    applyRaycast: true, collectPathContent: true);\r\n        Path copyOfPath = <b>myPathQuery.threadSafeResult\r.Copy();</b>
    //create path copy\n        <b>copyOfPath.ReturnToPool();</b> //return copy of
    path to pool so it can be reused again\n    }\r"
  - "Query to collect things that implementing ICellContentValueExternal interface.
    \nIt return result in form of <b>List<PointQueryResult<T>></b>\nwhere PointQueryResult
    is:"
  - '

    <b>Using Delegate</b>

    You can set delegate when path was generated
    in PathFinder thread or when it was recieved to threadSafe variable.'
  - "void Start() {\r\n    myPathQuery = new NavMeshPathQueryGeneric(properties,
    this);\r\n   myPathQuery.SetOnFinishedDelegate(MyPathDelegate, AgentDelegateMode.ThreadSafe);\n}\r\n\nvoid
    MyPathDelegate(Path path){\n    Debug.Log(\"Path have \" + myPathQuery.threadSafeResult.count
    + \" nodes\");\n}"
  - '

    <b>1) Create Query</b>

    Use the constructor. It reqire AgentProperties
    that specify what navmesh should be used and generic type that require inheretance
    from ICellContentValue and that value should be registered on navmesh.

    Or
    you can inherit from NavMeshContent class to use it in your components so it
    call PathFinder API on it''s own.'
  - "//example content that only have position and max distance\nclass <b>MyPoint</b>
    : ICellContentValueExternal {\r\n    public Vector3 position { get; private set;
    }\r\n    public float maxNavmeshDistance {\r\n        get { return float.MaxValue;
    }\r\n    }\r\n}\n\npublic AgentProperties myProperties;\nprivate NavMeshPointQuery<<b>MyPoint</b>>
    myQuery;\n\nvoid Start(){\n    myQuery = new NavMeshPointQuery<<b>MyPoint</b>>(myProperties);\n}"
  - "\n<b>2) Queue Points</b>\nAfter you create Query you should use it's function
    <color=blue><i>QueueWork</i>\r</color>\nIf have some amount of arguments and
    optional arguments:\n\u2022 <color=blue><i>Vector3 position</i>\r</color>: position
    from where search is performed\n\u2022 <color=blue><i>float maxCost</i>\r</color>:
    max cost on navmesh graph that query will check. large numbers lead to poor perfomance\n\u2022
    <color=blue><i>int layerMask</i>\r</color>: You can specify mask for searching
    on navmesh. this is optional argument. if you dont intrested in layered search
    you can set it to 1 in this case only default layer will be included\r\n\u2022
    <color=blue><i>int costModifierMask</i>\r</color>: You can specify mask for cost
    modifiers. this is optional argument. this is way to offset navmesh cost by external
    values \r\n\u2022 <color=blue><i>Predicate<ContentValueType> predicate</i>\r</color>:
    you can specify predicate for what points should be added. or leave it as null\r\n\u2022
    <color=blue><i>bool richCost</i>\r</color>: if true then calculate more accurate
    cost but this will do more expensive operations. \r\n\u2022 <color=blue><i>bool
    ignoreCrouchCost </i>\r</color>if true then crouch cost will be calculated as
    walking cost. for cases when Agent crouching all time\r\n\u2022 <color=blue><i>bool
    updatePathFinder</i>\r</color>: If true then after you queue work pathfinder
    will automaticaly updated. if you want to save up some perfomance you can batch
    some work within some time and call PathFinder.Update() youself\n\nThere is another
    version of that function but instead of single position if have input for multiple
    positions at same time\n\u2022 <color=blue><i>params Vector3[] positions</i>\r</color>\nIf
    multiple positions inside one navmesh part then only first will have correct
    cost if \"richCost\" setted to true\n\nAll arguments after \"position\" and \"maxCost\"
    is optional. I recomend to assign arguments by name. For example:"
  - "public struct PointQueryResult<T> {\r\n    public T value;      \r\n    public
    float cost;\n}"
  - It will contain result value and move cost over navmesh.
  - "public class ExampleClass : MonoBehaviour, IPathOwner {\r\n    public AgentProperties
    properties;\r\n    public float maxDistance;\n    private NavMeshPointQuery myPointQuery;\r\n\r\n  
    void Start() {\r\n        myPointQuery = new NavMeshPointQuery<MyPoint >(properties,
    this);\r\n    }\r\n\r\n    void Update() {\r\n         <b>myPointQuery.QueueWork(transform.position,
    maxDistance, richCost: true);\r</b>\n    }\n}"
  - Query will only return results for this generic type.
  - "\n<b>3) Receive Result</b>\nAfter you queue Points this query will add itself
    to current queue of queries and optionaly force PathFinder to update. When PathFinder
    update itself in it's own thread Query will perform searching of target type
    of points with optional predicate.\nAfter it all done you can use <color=blue><i>threadSafeResult</i>\r</color>
    variable inside query"
  - "    void Update() {\r\n        myPointQuery.QueueWork(transform.position, maxDistance,
    richCost: true);\n        foreach (var point in <b>myPointQuery.threadSafeResult</b>)
    {\r\n            Debug.Log(\"Value \" + point.value + \" have \" + point.cost
    + \"cost over navmesh\");\r\n        }\r\n    }      "
  - Cost calculated is not as distance of actual path there but cost over navmesh
    graph. It is not very accurate but cost for point near Agent and cost for point
    behind wall will be noticeable different.
  - '

    <b>Using Delegate</b>

    You can set delegate when result was generated
    in PathFinder thread or when it was recieved to threadSafe variable.

    It
    have some funky type since result is list of struct that contain generic type
    variable'
  - "void Start() {\r\n    myPointQuery = new NavMeshPointQuery<<b>MyPoint</b> >(properties,
    this);\r\n    myPointQuery.SetOnFinishedDelegate(MyPathDelegate, AgentDelegateMode.ThreadSafe);\n}\r\n\nvoid
    MyPointDelegate(List<PointQueryResult<<b>MyPoint</b>>> points){\n    foreach
    (var item in points) {\r\n        Debug.Log(item.ToString());\r\n    }\n}"
  - 'List of queries with short description that probably will be changed over time


    <b>NavMeshPathQueryTargetArea</b>

    Returns
    Path to nearest specific Area. Userful when some space is marked by Area and
    you dont care which one Agent should choose but he must go there.


    <b>NavMeshPathQueryTargetArea</b>

    Returns
    Path to nearest navMesh content of specific type with optional delegate


    <b>NavMeshPathQueryVectored</b>

    Return
    Path in some general direction with specific distance.


    <b>NavMeshQuerySamplePosition</b>

    Collect
    navmesh position closest to target point or specific set of points. It is not
    very handy to use Query just to get nearest navmesh position but this is most
    threadsafe option.


    <b>NavMeshQueryRaycastGeneric</b>

    Performs raycasting
    on navmesh


    <b>NavMeshQueryRaycastGeneric</b>

    Performs raycasting on
    navmesh


    <b>NavMeshQueryNavmeshToMesh</b>

    Collect target Area and Property
    navmesh edges and triangles'
  - "Used to describe set of waypoints with additional information. Actual code in
    PathFinder/PathInformation.cs if you want to read.\r\n\n<b><size=20>Public Variables</size></b>\n\n<color=blue><i>List<PathNode>
    pathNodes</i>\r</color> that describe path. \nPathNode is struct with (x, y,
    z) in world space and and PathNodeType."
  - "public struct PathNode {\r\n    public float x, y, z;\r\n    public PathNodeType
    type;\r\n}"
  - "<b>PathNodeType</b> are used to describe what kind of node there is:\n\u2022
    <color=blue><i>Invalid</i>\r</color>: This value will be when Path no longer
    have valid nodes.\n\u2022 <color=blue><i>MoveCrouch</i>\r</color>: To reach this
    position from previous Agent should crouch\n\u2022 <color=blue><i>MoveWalk </i>\r</color>:
    To reach this position from previous Agent can either crouch or just walk\n\u2022
    <color=blue><i>JumpUpFirstNode </i>\r</color>: Node where agent should stand
    when performing jump up\n\u2022 <color=blue><i>JumpUpSecondNode</i>\r</color>:
    Node that hanging over to end jump up"
  - "\u2022 <color=blue><i>JumpDownFirstNode</i>\r</color>: node where jump down
    performed\n\u2022 <color=blue><i>JumpDownSecondNode </i>\r</color>: landing point"
  - "\n<color=blue><i>PathResultType pathType</i>\r</color>: variable to troubleshoot
    path. \n\n<b>PathResultType</b>:\n\u2022 <color=blue><i>Valid\r</i></color>:
    Path is fully valid\n\u2022 <color=blue><i>BestFit</i></color>: Path returned
    best fit and did not reach target\n\u2022 <color=blue><i>InvalidAgentOutsideNavmesh</i>\r</color>:
    Agent was outside navmesh\n\u2022 <color=blue><i>InvalidTargetOutsideNavmesh</i>\r</color>:
    Target position was outside navmesh \n\u2022 <color=blue><i>InvalidNoPath</i>\r</color>:
    No valid path\n\u2022 <color=blue><i>InvalidExceedTimeLimit</i>\r</color>: Path
    seach was too long\n\u2022 <color=blue><i>InvalidInternalIssue</i>\r</color>:
    It did not fit in any category above and something went really wrong\n\n<color=blue><i>IPathOwner
    owner</i>\r</color>: current Path owner. It return fallback position.\n\r<color=blue><i>float
    pathNavmeshCost</i>\r</color>: Aproximated navmesh cost for quick comparison
    of 2 Paths."
  - "<b><size=20>Properties and Functions</size></b>\n\r<color=blue><i>bool valid
    {get;}</i>\r</color>: returns true if pathType is Valid or BestFit and owner
    is not a null\n\r<color=blue><i>int currentIndex {get;}</i>\r</color> return
    current index in nodes list\n\r<color=blue><i>int count {get;}</i>\r</color>:
    return total nodes count minus current node index\n\r<color=blue><i>PathNode
    currentNode{get;}</i>\r</color>: node at current index of path\n\r<color=blue><i>PathNode
    lastNode {get;}</i>\r</color>: last node in path\n\r<color=blue><i>Vector3 currentV3
    {get;}</i>\r</color>: (x,y,z) position of current node\n\r<color=blue><i>Vector2
    currentV2 {get;}</i>\r</color>: (x,z) position of current node\n\r<color=blue><i>Vector3
    lastV3 {get;}</i>\r</color>: (x,y,z) position of last node\n\r<color=blue><i>Vector2
    lastV2 {get;}</i>\r</color>: (x,z) position of last node\n\r<color=blue><i>bool
    MoveToNextNode()</i>\r</color> increase current node index by 1. returns if index
    was increased\n\r<color=blue><i>void SetCurrentIndex(int value)</i>\r</color>
    jump to some particular node\n\r<color=blue><i>bool MovableDistanceLesserThan(Vector3
    ownerPosition, float targetDistance, out float distance, out PathNode node, out
    bool reachLastPoint)</i>\r</color> Iterate over remaining nodes from target position
    and tellsif there is jumping node in target distance. Userful for handling animation
    of jump before you reach actual jump node in Path. Have lots of overloads"
  - "<b><size=20>Pooling</size></b>\nPath is object and it is taken from pool. Creating
    and destroying objects is expensive so there is object pool for Path. It is taken
    from pool when it generated and returned to pool when no longer required.\n\r<color=blue><i>Path
    Copy()</i>\r</color>: Use this when you need copy of Path. Takes from pool new
    Path, copy to it current Path\n\r<color=blue><i>void ReturnToPool()</i>\r</color>:
    When you done with copy return this Path to pool when it no longer required.\n"
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  stringArrayFilled: 120
  stringArrayFreeStack: 0100000002000000450000004d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  stringArrayFreeStackCount: 2
  textureArray:
  - {fileID: 0}
  - {fileID: 2800000, guid: 0f6cb2f7c72ab0047b41cb260b04a8a8, type: 3}
  - {fileID: 2800000, guid: db974d42276d6c0499efface5d8cab5e, type: 3}
  - {fileID: 2800000, guid: d57d552eab6729744868c93b218b14da, type: 3}
  - {fileID: 2800000, guid: c02d4d4f24b5167479333b35b4dab943, type: 3}
  - {fileID: 2800000, guid: 982ee2daa53f404438029ea1f06723cd, type: 3}
  - {fileID: 2800000, guid: 3d99d475b98dfd14daf5e0c17e5a1484, type: 3}
  - {fileID: 2800000, guid: 113b2085d0458be4ebeb35859b725a5b, type: 3}
  - {fileID: 2800000, guid: bd94ec9dd2b26ce4c914d3af9e244c9c, type: 3}
  - {fileID: 2800000, guid: 5041892b9a99204419bdb373cf3efd30, type: 3}
  - {fileID: 2800000, guid: a9f6da8edd38b61459f239fae94b4cba, type: 3}
  - {fileID: 2800000, guid: 736b5235bd42ec24c9db01c54fc29712, type: 3}
  - {fileID: 2800000, guid: 6e6b0e3260593fb40af9fb201e6265b7, type: 3}
  - {fileID: 2800000, guid: d433d9ca9117fe24d833bd7a2c3a0540, type: 3}
  - {fileID: 2800000, guid: bc786b26a521b3e4fa39b325303ddbd0, type: 3}
  - {fileID: 2800000, guid: 27213a427146d8b448bbda992931beae, type: 3}
  - {fileID: 2800000, guid: d113f6656a3e0c4448cb548fabbd100d, type: 3}
  - {fileID: 2800000, guid: dd06e59cf4a19de41855d372c12fb0d6, type: 3}
  - {fileID: 2800000, guid: ae0140da86561554e8a666bf87d3a888, type: 3}
  - {fileID: 2800000, guid: a041196a1a81e8d4487a00861e4a3ebd, type: 3}
  - {fileID: 2800000, guid: 8d226711b44cc6c4c840b6380e87e7ed, type: 3}
  - {fileID: 2800000, guid: 4c8923abeb86e2f45a700f6dcfdc5bd0, type: 3}
  - {fileID: 2800000, guid: 2899c5ede251a5e47865fff42365b2c4, type: 3}
  - {fileID: 2800000, guid: 69425ce0a8bdb8b4083473185332c2f2, type: 3}
  - {fileID: 2800000, guid: ac9ec9c0c60e1894595536d7f8e4beac, type: 3}
  - {fileID: 2800000, guid: 5901176c1114cb941a29e0c19b77e892, type: 3}
  - {fileID: 2800000, guid: 53e9288f96e079e47a25f83b29be9581, type: 3}
  - {fileID: 2800000, guid: af6f56a0729b86a4a97cfb9cb83972e0, type: 3}
  - {fileID: 2800000, guid: 071fe4f7a6d2c9e47bbf8bf8783ddc62, type: 3}
  - {fileID: 2800000, guid: 6e6b0e3260593fb40af9fb201e6265b7, type: 3}
  - {fileID: 2800000, guid: 00eea055635aa96419eddbe1c19ecf9d, type: 3}
  - {fileID: 2800000, guid: 2b3fdbcc23e6af24aac6a4e5ed93d03b, type: 3}
  - {fileID: 2800000, guid: 07203f68eb65a084db673e5aad04535b, type: 3}
  - {fileID: 2800000, guid: 0f05a8dccbdbd1a41aee994796cdcf1b, type: 3}
  - {fileID: 2800000, guid: 7693c0e751e332e4ba86ec923fbf3ef3, type: 3}
  - {fileID: 2800000, guid: a4cf0ffec2e854747b909b0446622099, type: 3}
  - {fileID: 2800000, guid: a041196a1a81e8d4487a00861e4a3ebd, type: 3}
  - {fileID: 2800000, guid: af6f56a0729b86a4a97cfb9cb83972e0, type: 3}
  - {fileID: 2800000, guid: 96747faef5b93004696a6910f7e27834, type: 3}
  - {fileID: 2800000, guid: 7693c0e751e332e4ba86ec923fbf3ef3, type: 3}
  - {fileID: 2800000, guid: 9e5eaf3713f1b3c44bced673d0f1057f, type: 3}
  - {fileID: 2800000, guid: 94e783c8689df2540ad1793cba52a0e3, type: 3}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  - {fileID: 0}
  textureArrayFilled: 42
  textureArrayFreeStack: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  textureArrayFreeStackCount: 1
  data:
  - header: General
    isOpen: 1
    sellection: -1
    data:
    - header: Overview
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 0
    - header: Helpful Attributes
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 58
      - dataType: 2
        value: 75
      - dataType: 0
        value: 74
      - dataType: 1
        value: 32
      - dataType: 0
        value: 59
      - dataType: 2
        value: 80
      - dataType: 0
        value: 81
      - dataType: 1
        value: 33
      - dataType: 0
        value: 62
      - dataType: 2
        value: 82
      - dataType: 0
        value: 83
      - dataType: 1
        value: 34
  - header: Main Menu
    isOpen: 1
    sellection: -1
    data:
    - header: Overview
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 24
      - dataType: 1
        value: 13
      - dataType: 0
        value: 25
    - header: General
      scroll: {x: 0, y: 706}
      contents:
      - dataType: 0
        value: 26
      - dataType: 1
        value: 14
      - dataType: 0
        value: 27
      - dataType: 0
        value: 28
      - dataType: 1
        value: 15
      - dataType: 0
        value: 29
      - dataType: 0
        value: 30
      - dataType: 0
        value: 31
    - header: Settings
      scroll: {x: 0, y: 931}
      contents:
      - dataType: 0
        value: 32
      - dataType: 1
        value: 16
      - dataType: 0
        value: 33
      - dataType: 0
        value: 34
      - dataType: 1
        value: 17
      - dataType: 0
        value: 35
      - dataType: 0
        value: 36
      - dataType: 1
        value: 18
      - dataType: 0
        value: 37
      - dataType: 0
        value: 38
      - dataType: 1
        value: 19
      - dataType: 0
        value: 39
    - header: Debuger
      scroll: {x: 0, y: 180}
      contents:
      - dataType: 0
        value: 40
      - dataType: 1
        value: 20
      - dataType: 0
        value: 41
      - dataType: 0
        value: 42
      - dataType: 1
        value: 21
      - dataType: 0
        value: 43
      - dataType: 1
        value: 22
      - dataType: 0
        value: 44
      - dataType: 0
        value: 45
  - header: Properties
    isOpen: 1
    sellection: -1
    data:
    - header: Overview
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 8
      - dataType: 1
        value: 6
      - dataType: 0
        value: 9
    - header: General
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 3
      - dataType: 1
        value: 1
      - dataType: 0
        value: 10
    - header: Voxel
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 4
      - dataType: 1
        value: 2
      - dataType: 0
        value: 11
      - dataType: 1
        value: 7
      - dataType: 0
        value: 12
    - header: Movement
      scroll: {x: 0, y: 250}
      contents:
      - dataType: 0
        value: 5
      - dataType: 1
        value: 3
      - dataType: 0
        value: 13
      - dataType: 1
        value: 8
      - dataType: 0
        value: 14
      - dataType: 1
        value: 9
      - dataType: 0
        value: 15
    - header: Cover
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 6
      - dataType: 1
        value: 4
      - dataType: 0
        value: 16
      - dataType: 1
        value: 10
      - dataType: 0
        value: 17
    - header: Samples
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 7
      - dataType: 1
        value: 5
      - dataType: 0
        value: 18
      - dataType: 1
        value: 11
  - header: Agent
    isOpen: 1
    sellection: -1
    data:
    - header: Overview
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 19
      - dataType: 1
        value: 12
      - dataType: 0
        value: 22
    - header: Handy Stuff
      scroll: {x: 0, y: 476}
      contents:
      - dataType: 0
        value: 23
  - header: Queries and Results
    isOpen: 1
    sellection: -1
    data:
    - header: Overview
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 20
    - header: NavMeshPathQueryGeneric
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 21
      - dataType: 2
        value: 88
      - dataType: 0
        value: 89
      - dataType: 2
        value: 92
      - dataType: 0
        value: 93
      - dataType: 2
        value: 94
      - dataType: 0
        value: 95
      - dataType: 2
        value: 96
      - dataType: 0
        value: 98
      - dataType: 2
        value: 99
    - header: NavMeshPointQuery
      scroll: {x: 0, y: 832}
      contents:
      - dataType: 0
        value: 97
      - dataType: 2
        value: 103
      - dataType: 0
        value: 104
      - dataType: 0
        value: 100
      - dataType: 2
        value: 101
      - dataType: 0
        value: 106
      - dataType: 0
        value: 102
      - dataType: 2
        value: 105
      - dataType: 0
        value: 107
      - dataType: 2
        value: 108
      - dataType: 0
        value: 109
      - dataType: 0
        value: 110
      - dataType: 2
        value: 111
    - header: Misc Queries
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 112
    - header: Path
      scroll: {x: 0, y: 966}
      contents:
      - dataType: 0
        value: 113
      - dataType: 2
        value: 114
      - dataType: 0
        value: 115
      - dataType: 1
        value: 40
      - dataType: 0
        value: 116
      - dataType: 1
        value: 41
      - dataType: 0
        value: 117
      - dataType: 0
        value: 118
      - dataType: 0
        value: 119
  - header: Local Avoidance
    isOpen: 1
    sellection: -1
    data:
    - header: Local Avoidance Manual
      scroll: {x: 0, y: 833}
      contents:
      - dataType: 0
        value: 63
      - dataType: 1
        value: 29
      - dataType: 0
        value: 54
  - header: Components
    isOpen: 1
    sellection: 0
    data:
    - header: AreaGameObject
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 45
      - dataType: 1
        value: 23
      - dataType: 0
        value: 46
    - header: AreaModifier
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 47
      - dataType: 1
        value: 24
      - dataType: 0
        value: 48
      - dataType: 1
        value: 25
      - dataType: 0
        value: 49
      - dataType: 1
        value: 26
      - dataType: 0
        value: 50
      - dataType: 1
        value: 27
      - dataType: 0
        value: 51
    - header: TerrainNavmeshSettings
      scroll: {x: 0, y: 66}
      contents:
      - dataType: 0
        value: 55
      - dataType: 1
        value: 30
      - dataType: 0
        value: 56
      - dataType: 1
        value: 31
      - dataType: 0
        value: 57
  - header: Features and Limitations
    isOpen: 1
    sellection: -1
    data:
    - header: Cost Modifier
      scroll: {x: 0, y: 180}
      contents:
      - dataType: 0
        value: 64
      - dataType: 1
        value: 35
      - dataType: 0
        value: 65
      - dataType: 1
        value: 28
      - dataType: 0
        value: 52
    - header: Cell Path Content
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 61
      - dataType: 2
        value: 90
      - dataType: 0
        value: 91
    - header: NavMesh Content
      scroll: {x: 0, y: 0}
      contents:
      - dataType: 0
        value: 60
      - dataType: 2
        value: 70
      - dataType: 0
        value: 71
    - header: Layers
      scroll: {x: 0, y: 657}
      contents:
      - dataType: 0
        value: 53
      - dataType: 1
        value: 36
      - dataType: 0
        value: 66
      - dataType: 1
        value: 37
      - dataType: 0
        value: 67
      - dataType: 1
        value: 38
      - dataType: 0
        value: 69
      - dataType: 2
        value: 84
      - dataType: 0
        value: 85
      - dataType: 2
        value: 86
      - dataType: 0
        value: 87
      - dataType: 1
        value: 39
